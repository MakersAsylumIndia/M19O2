#Copyright (c) 2018 Daniel B. Grunberg
#
#This program is free software: you can redistribute it and/or modify
#it under the terms of the GNU General Public License as published by
#the Free Software Foundation, either version 3 of the License, or
#(at your option) any later version.
#
#This program is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.
#
#You should have received a copy of the GNU General Public License
#along with this program.  If not, see <http://www.gnu.org/licenses/>.
import sys
import math
import collections
import matplotlib.pyplot as plt
import numpy as np
import scipy
import scipy.integrate
import matplotlib
import termios
import tty
import pprint
import argparse
import time
import datetime
import os
import warnings
import functools
'''
Plot the data generated by psa or from a pickle file
'''
#Please use python 3.6 or newer
vinfo=sys.version_info
assert vinfo.major >= 3 and vinfo.minor>=6
class Obj():
  pass

def v_to_mps(x, norm_v0=None):
  #velocity conversions between normalized and meters/sec
  return x*norm_v0

def mps_to_v(x, norm_v0=None):
  #velocity conversions
  return x/norm_v0

def plot(data, roi=None, pause=False, out_place='./plot', cycles=None,text=''):
  #data has data.data1 = generated data for container 1
  #         data.data2 = generated data for container 2
  #         data.datap = generated data for product
  #         data.t     = time values returned from ODE solver
  #         data.param = the parameter values for the sim
  #         data.ret   = the returned values from the sim
  #         Also added to state vars are:
  #           data?.V  = velocity
  #           data?.xAs = equilibrium of A
  #           data?.xBs = equilibrium of B
  #pause: whether to show the plots
  #out_place: directory+logcode that we can append our filename to
  #e.g. out/ab123
  #cycles is None for plot everything, or an int for a single cycle, or
  #a tuple (a,b) to plot everything from a to b inclusive.  cycle 0 is the first 1
  #text is some text to identify the plot (like filename, etc)
  if pause:
    #so we can stop and still get Enter input from user
    plt.ion()
  param=data.param
  bunch=Obj()
  bunch.t=data.t
  #plt.rcParams['figure.figsize']=6.5,3
  #plt.rcParams['figure.dpi']=150
  #plt.rcParams['savefig.dpi']=300
  #For the time plots, we need to create a mask that chooses which times to
  #display
  if cycles is None:
    #everything
    mask=(data.t >= 0)
    cycle_string=''
  elif isinstance(cycles,int):
    mask=np.logical_and(data.t >= data.param.cycle_time*cycles, data.t <= data.param.cycle_time*(cycles+1))
    cycle_string='cycle {}'.format(cycles)
  elif len(cycles)==2:
    mask=np.logical_and(data.t >= data.param.cycle_time*cycles[0],data.t <= data.param.cycle_time*(cycles[1]+1))
    cycle_string='cycles {}-{}'.format(cycles[0],cycles[1])
  else:
    raise ValueError("plots(): bad cycles argument {}".format(cycles))
  #times that will be plotted
  times=data.t[mask]
  #compute the times where a cycle and vent times should be placed
  first_cycle_time=(min(times)//param.cycle_time+1)*param.cycle_time
  cycle_time_bars=np.arange(first_cycle_time,max(times),param.cycle_time)
  vent_time_bars=np.arange(first_cycle_time-param.cycle_time+param.vent_time,max(times),param.cycle_time)
  #Select about 10 time points to display positional data.  If cycles is None,
  #use last cycle, otherwise use the displayed range
  #this is overridden if a roi of (min,max) time range is given
  if roi is not None:
    rng=list(roi)   # (min,max)
  elif cycles is None:
    rng=[max(data.t)-param.cycle_time,max(data.t)]
  else:
    rng=[min(times),max(times)]   # do everything
  #if asking for more than we plotted, adjust
  if rng[1] > max(data.t):
    dist=rng[1]-rng[0]
    rng[0]=max(bunch.t)-dist
    rng[1]=max(bunch.t)
  q=np.logical_and(rng[0] <= bunch.t, bunch.t <= rng[1])
  n=sum(q)
  tdec=np.copy(data.t)
  if n>12:
    dec=int((n+5)/12)
    q=np.logical_and(q, np.arange(0,len(bunch.t)) % dec == 0)
    #q is True at the places we want to sample data
    tdec=tdec[q]

  ##########################################3
  ### Spatial plots of Velocity, Pressure, and yA
  for i,d in enumerate((data.data1,data.data2)):
    fig,axs=plt.subplots(3,1,sharex=True)
    ax1,ax2,ax3=axs
    lines=ax2.plot(d.P[:,q], label='Pressure')
    fig.legend(iter(lines), ['t={:6.4f}'.format(t) for t in tdec],
               loc="center right", borderaxespad=0.1)
    ax2.set_title('Pressure - Container {}'.format(i+1),pad=3)
    ax2.set_ylim(bottom=0)
    ax3.set_xlabel('position z')
    ax1.plot(d.V[:,q])
    ax1.set_title('velocity - Container {} {}'.format(i+1,text),pad=3)
    ax1.set_ylabel('vel [normalized]')
    v_to_mps2=functools.partial(v_to_mps, norm_v0=data.param.norm_v0)
    mps_to_v2=functools.partial(v_to_mps, norm_v0=data.param.norm_v0)
    secax=ax1.secondary_yaxis('right', functions=(v_to_mps2,mps_to_v2))
    secax.set_ylabel('vel [m/s]')
    plt.subplots_adjust(right=.77)
  
    ax3.plot(d.yA[:,q])
    ax3.set_title('yA - Container {}'.format(i+1),pad=3)
    ax3.set_ylim(bottom=0)
    plt.tight_layout()
    plt.savefig('{}-space{}.svg'.format(out_place,i+1))
  ###############################################
  #### Time plots of Velocity, Pressure, yA
  mid=int(param.N/2)
  for i,d in enumerate((data.data1,data.data2)):
    fig,axs=plt.subplots(3,1,sharex=True)
    ax1,ax2,ax3=axs
    #draw the vertical cycle and crossvalve bars
    for ax in axs:
      for t in cycle_time_bars:
        ax.vlines(t, 0,1, linestyles='dashed')
      for t in vent_time_bars:        
        ax.vlines(t,0,0.25,linestyles='dotted')
    ax1.set_title('velocity vs time (container {}) {} {}'.format(i+1,cycle_string,text))
    #ax1.plot(bunch.t, vin, label='in flow')  #marker='.'
    #ax1.plot(bunch.t, vout, label='out flow')
    ax1.plot(times, d.V[mid,mask], label='mid flow')
    ax1.plot(times, d.V[1,mask], label='V1 flow')
    ax1.plot(times, d.V[-2,mask], label='VN flow')
    ax1.legend()
    ax1.set_ylabel('flow rate (normalized)')
    #ax1.set_ylabel('flow Ncm3/s')
    #secax=ax1.secondary_yaxis('right', functions=(cm_to_lpm,lpm_to_cm))
    #secax.set_ylabel('flow (slpm)')
    ax2.plot(times,d.P[0,mask], label='P1')
    ax2.plot(times,d.P[mid,mask], label='Pmid')
    ax2.plot(times,d.P[-1,mask],label='PN')
    ax2.plot(times,data.datap.Pprod[0,mask].ravel(), label='Product', color='r')
    ax2.set_ylim(bottom=0)
    ax2.legend()
    ax2.set_title('Pressure')
    ax3.plot(times, d.yA[0,mask], label='yA1 (in)')
    ax3.plot(times, d.yA[param.N-1,mask], label='yAN (out)')
    ax3.legend()
    ax3.set_title('yA - fraction O2')
    ax3.set_ylabel('fraction')
    ax3.set_ylim(bottom=0)
    ax3.set_xlabel('time (normalized)')
    plt.tight_layout()
    plt.savefig('{}-time{}.svg'.format(out_place,i+1))
  #####################################3
  ### Plot adsorbed equilibrium and adsorbed amount (xAs and xA) over time
  #fig,(ax1,ax2,ax3,ax4)=plt.subplots(4,1,sharex=True,
  #                                   gridspec_kw={'height_ratios':[3,3,3,1]})
  fig,(ax1,ax2)=plt.subplots(2,1,sharex=True)
  ax1.plot(times,data.data1.xAs[0,mask], label='xA eq 1')
  ax1.plot(times,data.data1.xAs[mid,mask], label='xA eq mid')
  ax1.plot(times,data.data1.xAs[-1,mask], label='xA eq N')
  ax1.plot(times,data.data1.xA[0,mask],label='xA 1')
  ax1.plot(times,data.data1.xA[mid,mask],label='xA mid')
  ax1.plot(times,data.data1.xA[-1,mask],label='xA N')
  ax1.set_title('Solid Phase A {} {}'.format(cycle_string,text))
  ax1.legend()
  #ax1.set_xlim(left=0)
  ax1.set_ylim(bottom=0)

  ax2.plot(times,data.data1.xBs[0,mask], label='xB eq 1')
  ax2.plot(times,data.data1.xBs[mid,mask], label='xB eq mid')
  ax2.plot(times,data.data1.xBs[-1,mask], label='xB eq N')
  ax2.plot(times,data.data1.xB[0,mask], label='xB 1')
  ax2.plot(times,data.data1.xB[mid,mask], label='xB mid')
  ax2.plot(times,data.data1.xB[-1,mask], label='xB N')  
  ax2.set_title('Solid Phase B')
  ax2.set_ylim(bottom=0)
  ax2.set_xlabel('time (normalized)')
  plt.tight_layout()
  plt.savefig('{}-adsorbed.svg'.format(out_place))
  ############
  #Product tank plots over time
  fig,(ax1,ax2)=plt.subplots(2,1,sharex=True)
  for ax in (ax1,ax2):
    for t in cycle_time_bars:
      ax.vlines(t, 0,1, linestyles='dashed')
    for t in vent_time_bars:
      ax.vlines(t,0,0.25,linestyles='dotted')
  ax1.plot(times,data.datap.Pprod[0,mask], label='Product tank Pressure')
  ax1.set_title('Product Tank Pressure {} {}'.format(cycle_string,text))
  ax1.legend()
  ax1.set_ylim(bottom=0)

  ax2.plot(times,data.datap.yprod[0,mask])
  ax2.set_title('Product Tank O2 fraction')
  ax2.set_ylim(bottom=0)
  plt.tight_layout()
  plt.savefig('{}-product.svg'.format(out_place))

  if pause:
    plt.draw()
    input('press Enter...')
  #end of simulate
  plt.close('all')
